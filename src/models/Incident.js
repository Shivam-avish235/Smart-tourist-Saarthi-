import mongoose from 'mongoose';

const incidentSchema = new mongoose.Schema({
  incidentId: {
    type: String,
    unique: true,
    default: function() {
      return 'INC_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4).toUpperCase();
    }
  },
  touristId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Tourist',
    required: true
  },
  type: {
    type: String,
    required: true,
    enum: [
      'Panic Button',
      'Location Drop-off',
      'Route Deviation',
      'Prolonged Inactivity', 
      'Geofence Breach',
      'Health Emergency',
      'Communication Lost',
      'Weather Alert',
      'Security Threat',
      'Medical Emergency'
    ]
  },
  severity: {
    type: String,
    required: true,
    enum: ['Critical', 'High', 'Medium', 'Low'],
    default: 'Medium'
  },
  status: {
    type: String,
    enum: ['New', 'Acknowledged', 'In Progress', 'Resolved', 'Closed', 'False Alarm'],
    default: 'New'
  },
  priority: {
    type: Number,
    min: 1,
    max: 5,
    default: function() {
      const priorityMap = { 'Critical': 1, 'High': 2, 'Medium': 3, 'Low': 4 };
      return priorityMap[this.severity] || 3;
    }
  },
  location: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number], // [longitude, latitude]
      required: true
    },
    address: String,
    landmark: String
  },
  description: {
    type: String,
    required: true,
    maxlength: 500
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  reportedBy: {
    type: String, // 'Tourist', 'System', 'Admin', etc.
    default: 'Tourist'
  },
  assignedTo: {
    type: String, // Response team or officer
    default: null
  },
  responseTime: {
    type: Number, // in minutes
    default: null
  },
  resolution: {
    type: String,
    maxlength: 1000
  },
  evidence: [{
    type: String, // URLs to images, videos, etc.
    url: String,
    description: String,
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  notifications: [{
    type: String, // 'SMS', 'Email', 'Push', 'Call'
    recipient: String,
    sentAt: {
      type: Date,
      default: Date.now
    },
    status: {
      type: String,
      enum: ['Sent', 'Delivered', 'Failed'],
      default: 'Sent'
    }
  }],
  escalated: {
    type: Boolean,
    default: false
  },
  escalatedAt: Date,
  escalatedTo: String
}, {
  timestamps: true
});

// Create geospatial index for location-based queries
incidentSchema.index({ location: '2dsphere' });

// Indexes for common queries
incidentSchema.index({ touristId: 1, createdAt: -1 });
incidentSchema.index({ status: 1, severity: 1 });
incidentSchema.index({ createdAt: -1 });

// Auto-escalate critical incidents if not acknowledged in 5 minutes
incidentSchema.methods.checkEscalation = function() {
  if (this.severity === 'Critical' && this.status === 'New') {
    const timeDiff = (new Date() - this.createdAt) / (1000 * 60); // minutes
    if (timeDiff > 5 && !this.escalated) {
      this.escalated = true;
      this.escalatedAt = new Date();
      this.escalatedTo = 'Emergency Services';
      return true;
    }
  }
  return false;
};

// Calculate SLA compliance
incidentSchema.methods.getSLAStatus = function() {
  const slaMinutes = {
    'Critical': 10,  // 10 minutes
    'High': 30,      // 30 minutes  
    'Medium': 120,   // 2 hours
    'Low': 480       // 8 hours
  };

  const maxTime = slaMinutes[this.severity] || 120;
  const currentTime = this.responseTime || ((new Date() - this.createdAt) / (1000 * 60));

  return {
    withinSLA: currentTime <= maxTime,
    timeRemaining: Math.max(0, maxTime - currentTime),
    overdue: currentTime > maxTime
  };
};

export default mongoose.model('Incident', incidentSchema);
