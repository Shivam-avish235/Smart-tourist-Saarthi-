import Incident from '../models/Incident.js';
import Tourist from '../models/Tourist.js';
import { getIO } from '../socket/socket.js';

// Create new incident
export const createIncident = async (req, res) => {
  try {
    const { touristId, type, severity, location, description, autoGenerated = false } = req.body;

    // Check if tourist exists
    const tourist = await Tourist.findById(touristId);
    if (!tourist) {
      return res.status(404).json({
        success: false,
        error: 'Tourist not found'
      });
    }

    const incident = new Incident({
      touristId,
      type,
      severity,
      location: location || tourist.currentLocation,
      description,
      autoGenerated,
      reportedBy: autoGenerated ? 'System' : req.user.id
    });

    await incident.save();

    // Update tourist risk level if critical
    if (severity === 'Critical' || severity === 'High') {
      tourist.riskLevel = 'High';
      tourist.geofenceStatus = 'Alert';
      await tourist.save();
    }

    // Emit real-time alert
    const io = getIO();
    io.emit('new_incident', {
      incident,
      tourist: {
        id: tourist._id,
        name: tourist.name,
        location: tourist.currentLocation
      }
    });

    res.status(201).json({ 
      success: true, 
      data: incident,
      message: 'Incident created successfully' 
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get all incidents with filtering
export const getAllIncidents = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    // Build filter
    const filter = {};
    if (req.query.severity) filter.severity = req.query.severity;
    if (req.query.status) filter.status = req.query.status;
    if (req.query.type) filter.type = req.query.type;
    if (req.query.touristId) filter.touristId = req.query.touristId;

    // Date range filter
    if (req.query.startDate || req.query.endDate) {
      filter.createdAt = {};
      if (req.query.startDate) filter.createdAt.$gte = new Date(req.query.startDate);
      if (req.query.endDate) filter.createdAt.$lte = new Date(req.query.endDate);
    }

    const incidents = await Incident.find(filter)
      .populate('touristId', 'name email country currentLocation')
      .skip(skip)
      .limit(limit)
      .sort({ createdAt: -1 });

    const total = await Incident.countDocuments(filter);

    res.json({
      success: true,
      data: incidents,
      pagination: {
        current: page,
        pages: Math.ceil(total / limit),
        total,
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

// Update incident status
export const updateIncidentStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, resolution, assignedTo } = req.body;

    const incident = await Incident.findById(id);
    if (!incident) {
      return res.status(404).json({
        success: false,
        error: 'Incident not found'
      });
    }

    incident.status = status;
    if (resolution) incident.resolution = resolution;
    if (assignedTo) incident.assignedTo = assignedTo;

    // Calculate response time if resolved
    if (status === 'Resolved' || status === 'Closed') {
      const responseTime = (new Date() - incident.createdAt) / (1000 * 60); // minutes
      incident.responseTime = Math.round(responseTime);
    }

    await incident.save();

    // Emit real-time update
    const io = getIO();
    io.emit('incident_updated', incident);

    res.json({ 
      success: true, 
      data: incident,
      message: `Incident ${status.toLowerCase()} successfully`
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get incident analytics
export const getIncidentAnalytics = async (req, res) => {
  try {
    const totalIncidents = await Incident.countDocuments();
    const activeIncidents = await Incident.countDocuments({
      status: { $in: ['New', 'In Progress'] }
    });
    const criticalIncidents = await Incident.countDocuments({
      severity: 'Critical',
      status: { $in: ['New', 'In Progress'] }
    });

    // Incident types distribution
    const typeDistribution = await Incident.aggregate([
      { $group: { _id: '$type', count: { $sum: 1 } } },
      { $sort: { count: -1 } }
    ]);

    // Average response time
    const avgResponseTime = await Incident.aggregate([
      { $match: { responseTime: { $exists: true } } },
      { $group: { _id: null, avgTime: { $avg: '$responseTime' } } }
    ]);

    // Incidents by severity
    const severityDistribution = await Incident.aggregate([
      { $group: { _id: '$severity', count: { $sum: 1 } } }
    ]);

    // Recent incidents (last 24 hours)
    const recentIncidents = await Incident.countDocuments({
      createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
    });

    res.json({
      success: true,
      data: {
        totalIncidents,
        activeIncidents,
        criticalIncidents,
        recentIncidents,
        averageResponseTime: avgResponseTime[0]?.avgTime || 0,
        typeDistribution,
        severityDistribution
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};
